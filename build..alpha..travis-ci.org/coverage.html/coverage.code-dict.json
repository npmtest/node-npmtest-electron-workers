{"/home/travis/build/npmtest/node-npmtest-electron-workers/test.js":"/* istanbul instrument in package npmtest_electron_workers */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-electron-workers/lib.npmtest_electron_workers.js":"/* istanbul instrument in package npmtest_electron_workers */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_electron_workers = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_electron_workers = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-electron-workers/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-electron-workers && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_electron_workers */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_electron_workers\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_electron_workers.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_electron_workers.rollup.js'] =\n            local.assetsDict['/assets.npmtest_electron_workers.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_electron_workers.__dirname + '/lib.npmtest_electron_workers.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-electron-workers/node_modules/electron-workers/lib/index.js":"'use strict';\n\nexports.__esModule = true;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _ElectronManager = require('./ElectronManager');\n\nvar _ElectronManager2 = _interopRequireDefault(_ElectronManager);\n\nvar _packageJson = require('../package.json');\n\nvar debugMe = _debug2['default'](_packageJson.name);\n\nfunction createManager(options) {\n  var manager = new _ElectronManager2['default'](options);\n  debugMe('Creating a new manager with options:', manager.options);\n  return manager;\n}\n\nfunction electronManager(options) {\n  return createManager(options);\n}\n\nexports['default'] = electronManager;\nmodule.exports = exports['default'];","/home/travis/build/npmtest/node-npmtest-electron-workers/node_modules/electron-workers/lib/ElectronManager.js":"\n/**\n * ElectronManager is responsible of managing pool of electron worker processes\n * and distributing tasks to them.\n */\n\n'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _events = require('events');\n\nvar _os = require('os');\n\nvar _os2 = _interopRequireDefault(_os);\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _which = require('which');\n\nvar _which2 = _interopRequireDefault(_which);\n\nvar _lodashFindindex = require('lodash.findindex');\n\nvar _lodashFindindex2 = _interopRequireDefault(_lodashFindindex);\n\nvar _ElectronWorker = require('./ElectronWorker');\n\nvar _ElectronWorker2 = _interopRequireDefault(_ElectronWorker);\n\nvar _packageJson = require('../package.json');\n\nvar numCPUs = _os2['default'].cpus().length,\n    debugManager = _debug2['default'](_packageJson.name + ':manager');\n\nvar ELECTRON_PATH = undefined;\n\nfunction getElectronPath() {\n  var electron = undefined;\n\n  if (ELECTRON_PATH) {\n    debugManager('getting electron path from cache');\n    return ELECTRON_PATH;\n  }\n\n  // first try to find the electron executable if it is installed from `electron`..\n  electron = getElectronPathFromPackage('electron');\n\n  if (electron == null) {\n    // second try to find the electron executable if it is installed from `electron-prebuilt`..\n    electron = getElectronPathFromPackage('electron-prebuilt');\n  }\n\n  if (electron == null) {\n    // last try to find the electron executable, trying using which module\n    debugManager('trying to get electron path from $PATH..');\n\n    try {\n      electron = _which2['default'].sync('electron');\n    } catch (whichErr) {\n      throw new Error('Couldn\\'t find the path to the electron executable automatically, ' + 'try installing the `electron` or `electron-prebuilt` package, ' + 'or set the `pathToElectron` option to specify the path manually');\n    }\n  }\n\n  ELECTRON_PATH = electron;\n\n  return electron;\n}\n\nfunction getElectronPathFromPackage(moduleName) {\n  var electronPath = undefined;\n\n  try {\n    debugManager('trying to get electron path from \"' + moduleName + '\" module..');\n\n    // eslint-disable-next-line global-require\n    electronPath = require(moduleName);\n\n    return electronPath;\n  } catch (err) {\n    if (err.code === 'MODULE_NOT_FOUND') {\n      return electronPath;\n    }\n\n    throw err;\n  }\n}\n\nvar ElectronManager = (function (_EventEmitter) {\n  _inherits(ElectronManager, _EventEmitter);\n\n  function ElectronManager() {\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    _classCallCheck(this, ElectronManager);\n\n    _EventEmitter.call(this);\n\n    var instance = this;\n\n    this._electronInstances = [];\n    this._electronInstancesTasksCount = {};\n    this.options = _extends({}, options);\n    this.options.connectionMode = this.options.connectionMode || 'server';\n    this.options.electronArgs = this.options.electronArgs || [];\n    this.options.pathToElectron = this.options.pathToElectron || getElectronPath();\n    this.options.numberOfWorkers = this.options.numberOfWorkers || numCPUs;\n    this.options.maxConcurrencyPerWorker = this.options.maxConcurrencyPerWorker || Infinity;\n    this.options.timeout = this.options.timeout || 10000;\n    this.options.host = this.options.host || 'localhost';\n    this.options.hostEnvVarName = this.options.hostEnvVarName || 'ELECTRON_WORKER_HOST';\n    this.options.portEnvVarName = this.options.portEnvVarName || 'ELECTRON_WORKER_PORT';\n    this._timeouts = [];\n    this.tasksQueue = [];\n\n    if (isNaN(this.options.maxConcurrencyPerWorker) || typeof this.options.maxConcurrencyPerWorker !== 'number') {\n      throw new Error('`maxConcurrencyPerWorker` option must be a number');\n    }\n\n    if (this.options.maxConcurrencyPerWorker <= 0) {\n      throw new Error('`maxConcurrencyPerWorker` option must be greater than 0');\n    }\n\n    function processExitHandler() {\n      debugManager('process exit: trying to kill workers..');\n      instance.kill();\n    }\n\n    this._processExitHandler = processExitHandler;\n\n    process.once('exit', processExitHandler);\n  }\n\n  ElectronManager.prototype.start = function start(cb) {\n    var _this = this;\n\n    var started = 0;\n    var workerErrors = [];\n    var _options = this.options;\n    var numberOfWorkers = _options.numberOfWorkers;\n    var connectionMode = _options.connectionMode;\n    var couldNotStartWorkersErr = undefined;\n\n    if (connectionMode !== 'server' && connectionMode !== 'ipc') {\n      return cb(new Error('invalid connection mode: ' + connectionMode));\n    }\n\n    debugManager('starting ' + numberOfWorkers + ' worker(s), mode: ' + connectionMode + '..');\n\n    function startHandler(err) {\n      if (err) {\n        workerErrors.push(err);\n      }\n\n      started++;\n\n      if (started === numberOfWorkers) {\n        if (workerErrors.length) {\n          couldNotStartWorkersErr = new Error('electron manager could not start all workers..');\n          couldNotStartWorkersErr.workerErrors = workerErrors;\n          debugManager('electron manager could not start all workers..');\n          return cb(couldNotStartWorkersErr);\n        }\n\n        debugManager('all workers started correctly');\n        cb(null);\n      }\n    }\n\n    var _loop = function (ix) {\n      var workerPortLeftBoundary = _this.options.portLeftBoundary,\n          workerOptions = undefined,\n          workerInstance = undefined;\n\n      // prevent that workers start with the same left boundary\n      if (workerPortLeftBoundary != null) {\n        workerPortLeftBoundary += ix;\n      }\n\n      workerOptions = {\n        debug: _this.options.debug,\n        debugBrk: _this.options.debugBrk,\n        env: _this.options.env,\n        stdio: _this.options.stdio,\n        connectionMode: _this.options.connectionMode,\n        killSignal: _this.options.killSignal,\n        electronArgs: _this.options.electronArgs,\n        pathToElectron: _this.options.pathToElectron,\n        pathToScript: _this.options.pathToScript,\n        hostEnvVarName: _this.options.hostEnvVarName,\n        portEnvVarName: _this.options.portEnvVarName,\n        host: _this.options.host,\n        portLeftBoundary: workerPortLeftBoundary,\n        portRightBoundary: _this.options.portRightBoundary\n      };\n\n      debugManager('creating worker ' + (ix + 1) + ' with options:', workerOptions);\n      workerInstance = new _ElectronWorker2['default'](workerOptions);\n\n      workerInstance.on('processCreated', function () {\n        _this.emit('workerProcessCreated', workerInstance, workerInstance._childProcess);\n      });\n\n      workerInstance.on('recycling', function () {\n        if (_this._electronInstancesTasksCount[workerInstance.id] != null) {\n          _this._electronInstancesTasksCount[workerInstance.id] = 0;\n        }\n\n        _this.emit('workerRecycling', workerInstance);\n      });\n\n      workerInstance.on('recyclingError', function () {\n        _this.emit('workerRecyclingError', workerInstance);\n        _this.tryFlushQueue();\n      });\n\n      workerInstance.on('recycled', function () {\n        _this.emit('workerRecycled', workerInstance);\n        _this.tryFlushQueue();\n      });\n\n      workerInstance.on('kill', function () {\n        if (_this._electronInstancesTasksCount[workerInstance.id] != null) {\n          _this._electronInstancesTasksCount[workerInstance.id] = 0;\n        }\n      });\n\n      _this._electronInstances.push(workerInstance);\n      _this._electronInstancesTasksCount[workerInstance.id] = 0;\n\n      _this._electronInstances[ix].start(startHandler);\n    };\n\n    for (var ix = 0; ix < numberOfWorkers; ix++) {\n      _loop(ix);\n    }\n  };\n\n  ElectronManager.prototype.execute = function execute(data) {\n    var availableWorkerInstanceIndex = undefined,\n        availableWorkerInstance = undefined,\n        options = undefined,\n        cb = undefined;\n\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    if (args.length > 1) {\n      options = args[0];\n      cb = args[1];\n    } else {\n      cb = args[0];\n    }\n\n    debugManager('getting new task..');\n\n    // simple round robin balancer across workers\n    // on each execute, get the first available worker from the list...\n    availableWorkerInstanceIndex = _lodashFindindex2['default'](this._electronInstances, {\n      isBusy: false\n    });\n\n    if (availableWorkerInstanceIndex !== -1) {\n      availableWorkerInstance = this._electronInstances.splice(availableWorkerInstanceIndex, 1)[0];\n\n      this._manageTaskStartInWorker(availableWorkerInstance);\n\n      debugManager('worker [' + availableWorkerInstance.id + '] has been choosen for the task..');\n\n      this._executeInWorker(availableWorkerInstance, data, options, cb);\n      // ..and then the worker we have used becomes the last item in the list\n      this._electronInstances.push(availableWorkerInstance);\n      return;\n    }\n\n    debugManager('no workers available, storing the task for later processing..');\n    // if no available worker save task for later processing\n    this.tasksQueue.push({ data: data, options: options, cb: cb });\n  };\n\n  ElectronManager.prototype._manageTaskStartInWorker = function _manageTaskStartInWorker(worker) {\n    var maxConcurrencyPerWorker = this.options.maxConcurrencyPerWorker;\n\n    if (this._electronInstancesTasksCount[worker.id] == null) {\n      this._electronInstancesTasksCount[worker.id] = 0;\n    }\n\n    if (this._electronInstancesTasksCount[worker.id] < maxConcurrencyPerWorker) {\n      this._electronInstancesTasksCount[worker.id]++;\n    }\n\n    // \"equality check\" is just enough here but we apply the \"greater than\" check just in case..\n    if (this._electronInstancesTasksCount[worker.id] >= maxConcurrencyPerWorker) {\n      worker.isBusy = true; // eslint-disable-line no-param-reassign\n    }\n  };\n\n  ElectronManager.prototype._manageTaskEndInWorker = function _manageTaskEndInWorker(worker) {\n    var maxConcurrencyPerWorker = this.options.maxConcurrencyPerWorker;\n\n    if (this._electronInstancesTasksCount[worker.id] == null) {\n      this._electronInstancesTasksCount[worker.id] = 0;\n    }\n\n    if (this._electronInstancesTasksCount[worker.id] > 0) {\n      this._electronInstancesTasksCount[worker.id]--;\n    }\n\n    if (this._electronInstancesTasksCount[worker.id] < maxConcurrencyPerWorker) {\n      worker.isBusy = false; // eslint-disable-line no-param-reassign\n    }\n  };\n\n  ElectronManager.prototype._executeInWorker = function _executeInWorker(worker, data, options, cb) {\n    var _this2 = this;\n\n    if (options === undefined) options = {};\n\n    var workerTimeout = undefined;\n\n    if (options.timeout != null) {\n      workerTimeout = options.timeout;\n    } else {\n      workerTimeout = this.options.timeout;\n    }\n\n    if (worker.shouldRevive) {\n      debugManager('trying to revive worker [' + worker.id + ']..');\n\n      worker.start(function (startErr) {\n        if (startErr) {\n          debugManager('worker [' + worker.id + '] could not revive..');\n          _this2.tryFlushQueue();\n          return cb(startErr);\n        }\n\n        debugManager('worker [' + worker.id + '] has revived..');\n        executeTask.call(_this2);\n      });\n    } else {\n      executeTask.call(this);\n    }\n\n    function executeTask() {\n      var _this3 = this;\n\n      var isDone = false;\n\n      var timeoutId = setTimeout(function () {\n        _this3._timeouts.splice(_this3._timeouts.indexOf(timeoutId), 1);\n\n        if (isDone) {\n          return;\n        }\n\n        debugManager('task timeout in worker [' + worker.id + '] has been reached..');\n\n        isDone = true;\n\n        _this3._manageTaskEndInWorker(worker);\n\n        _this3.emit('workerTimeout', worker);\n\n        var error = new Error();\n        error.workerTimeout = true;\n        error.message = 'Worker Timeout, the worker process does not respond after ' + workerTimeout + ' ms';\n        cb(error);\n\n        _this3.tryFlushQueue();\n      }, workerTimeout);\n\n      debugManager('executing task in worker [' + worker.id + '] with timeout:', workerTimeout);\n\n      this._timeouts.push(timeoutId);\n\n      worker.execute(data, function (err, result) {\n        if (isDone) {\n          return;\n        }\n\n        _this3._manageTaskEndInWorker(worker);\n\n        // clear timeout\n        _this3._timeouts.splice(_this3._timeouts.indexOf(timeoutId), 1);\n        clearTimeout(timeoutId);\n\n        if (err) {\n          debugManager('task has failed in worker [' + worker.id + ']..');\n          _this3.tryFlushQueue();\n          cb(err);\n          return;\n        }\n\n        isDone = true;\n        debugManager('task executed correctly in worker [' + worker.id + ']..');\n        _this3.tryFlushQueue();\n        cb(null, result);\n      });\n    }\n  };\n\n  ElectronManager.prototype.tryFlushQueue = function tryFlushQueue() {\n    var availableWorkerInstanceIndex = undefined,\n        availableWorkerInstance = undefined,\n        task = undefined;\n\n    debugManager('trying to flush queue of pending tasks..');\n\n    if (this.tasksQueue.length === 0) {\n      debugManager('there is no pending tasks..');\n      return;\n    }\n\n    // simple round robin balancer across workers\n    // get the first available worker from the list...\n    availableWorkerInstanceIndex = _lodashFindindex2['default'](this._electronInstances, {\n      isBusy: false\n    });\n\n    if (availableWorkerInstanceIndex === -1) {\n      debugManager('no workers available to process pending task..');\n      return;\n    }\n\n    task = this.tasksQueue.shift();\n    availableWorkerInstance = this._electronInstances.splice(availableWorkerInstanceIndex, 1)[0];\n\n    this._manageTaskStartInWorker(availableWorkerInstance);\n\n    debugManager('worker [' + availableWorkerInstance.id + '] has been choosen for process pending task..');\n\n    this._executeInWorker(availableWorkerInstance, task.data, task.options, task.cb);\n    // ..and then the worker we have used becomes the last item in the list\n    this._electronInstances.push(availableWorkerInstance);\n  };\n\n  ElectronManager.prototype.kill = function kill() {\n    debugManager('killing all workers..');\n\n    this._timeouts.forEach(function (tId) {\n      clearTimeout(tId);\n    });\n\n    this._electronInstances.forEach(function (workerInstance) {\n      workerInstance.kill(true);\n    });\n\n    process.removeListener('exit', this._processExitHandler);\n  };\n\n  return ElectronManager;\n})(_events.EventEmitter);\n\nexports['default'] = ElectronManager;\nmodule.exports = exports['default'];","/home/travis/build/npmtest/node-npmtest-electron-workers/node_modules/electron-workers/lib/ElectronWorker.js":"'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _events = require('events');\n\nvar _child_process = require('child_process');\n\nvar _child_process2 = _interopRequireDefault(_child_process);\n\nvar _cluster = require('cluster');\n\nvar _cluster2 = _interopRequireDefault(_cluster);\n\nvar _http = require('http');\n\nvar _http2 = _interopRequireDefault(_http);\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _netCluster = require('net-cluster');\n\nvar _netCluster2 = _interopRequireDefault(_netCluster);\n\nvar _portscanner = require('portscanner');\n\nvar _portscanner2 = _interopRequireDefault(_portscanner);\n\nvar _uuid = require('uuid');\n\nvar _uuid2 = _interopRequireDefault(_uuid);\n\nvar _checkPortStatus = require('./checkPortStatus');\n\nvar _checkPortStatus2 = _interopRequireDefault(_checkPortStatus);\n\nvar _checkIpcStatus = require('./checkIpcStatus');\n\nvar _checkIpcStatus2 = _interopRequireDefault(_checkIpcStatus);\n\nvar _packageJson = require('../package.json');\n\nvar debugWorker = _debug2['default'](_packageJson.name + ':worker');\n\nfunction findFreePort(host, cb) {\n  var server = _netCluster2['default'].createServer(),\n      port = 0;\n\n  debugWorker('trying to find free port..');\n\n  server.on('listening', function () {\n    port = server.address().port;\n    server.close();\n  });\n\n  server.on('close', function () {\n    cb(null, port);\n  });\n\n  server.listen(0, host);\n}\n\nfunction findFreePortInRange(host, portLeftBoundary, portRightBoundary, cb) {\n  var newPortLeftBoundary = portLeftBoundary;\n\n  // in cluster we don't want ports to collide, so we make a special space for every\n  // worker assuming max number of cluster workers is 5\n  if (_cluster2['default'].worker) {\n    newPortLeftBoundary = portLeftBoundary + (portRightBoundary - portLeftBoundary) / 5 * (_cluster2['default'].worker.id - 1);\n  }\n\n  debugWorker('trying to find free port in range ' + newPortLeftBoundary + '-' + portRightBoundary);\n\n  _portscanner2['default'].findAPortNotInUse(newPortLeftBoundary, portRightBoundary, host, function (error, port) {\n    cb(error, port);\n  });\n}\n\nfunction isValidConnectionMode(mode) {\n  if (mode !== 'server' && mode !== 'ipc') {\n    return false;\n  }\n\n  return true;\n}\n\nvar ElectronWorker = (function (_EventEmitter) {\n  _inherits(ElectronWorker, _EventEmitter);\n\n  function ElectronWorker(options) {\n    _classCallCheck(this, ElectronWorker);\n\n    _EventEmitter.call(this);\n\n    this.options = options;\n    this.firstStart = false;\n    this.shouldRevive = false;\n    this.exit = false;\n    this.isBusy = false;\n    this.isRecycling = false;\n    this.id = _uuid2['default'].v1();\n    this._hardKill = false;\n    this._earlyError = false;\n    this._taskCallback = {};\n\n    this.onWorkerProcessError = this.onWorkerProcessError.bind(this);\n    this.onWorkerProcessExitTryToRecyle = this.onWorkerProcessExitTryToRecyle.bind(this);\n    this.onWorkerProcessIpcMessage = this.onWorkerProcessIpcMessage.bind(this);\n\n    if (options.connectionMode === 'ipc') {\n      this.findFreePort = function (cb) {\n        cb(null);\n      };\n    } else {\n      if (options.portLeftBoundary && options.portRightBoundary) {\n        this.findFreePort = function (cb) {\n          findFreePortInRange(options.host, options.portLeftBoundary, options.portRightBoundary, cb);\n        };\n      } else {\n        this.findFreePort = function (cb) {\n          findFreePort(options.host, cb);\n        };\n      }\n    }\n  }\n\n  ElectronWorker.prototype.onWorkerProcessError = function onWorkerProcessError(workerProcessErr) {\n    debugWorker('worker [' + this.id + '] electron process error callback: ' + workerProcessErr.message);\n\n    // don't handle early errors (errors between spawning the process and the first checkAlive call) in this handler\n    if (this._earlyError) {\n      debugWorker('worker [' + this.id + '] ignoring error because it was handled previously (early): ' + workerProcessErr.message);\n      return;\n    }\n\n    // try revive the process when an error is received,\n    // note that could not be spawn errors are not handled here..\n    if (this.firstStart && !this.isRecycling && !this.shouldRevive) {\n      debugWorker('worker [' + this.id + '] the process will be revived because an error: ' + workerProcessErr.message);\n      this.shouldRevive = true;\n    }\n  };\n\n  ElectronWorker.prototype.onWorkerProcessExitTryToRecyle = function onWorkerProcessExitTryToRecyle() {\n    var _this = this;\n\n    debugWorker('worker [' + this.id + '] onWorkerProcessExitTryToRecyle callback..');\n\n    // we only recycle the process on exit and if it is not in the middle\n    // of another recycling\n    if (this.firstStart && !this.isRecycling) {\n      debugWorker('trying to recycle worker [' + this.id + '], reason: process exit..');\n\n      this.exit = true;\n      this.firstStart = false;\n\n      this.recycle(function () {\n        _this.exit = false;\n      });\n    }\n  };\n\n  ElectronWorker.prototype.onWorkerProcessIpcMessage = function onWorkerProcessIpcMessage(payload) {\n    var callback = undefined,\n        responseData = undefined;\n\n    if (payload && payload.workerEvent === 'taskResponse') {\n      debugWorker('task in worker [' + this.id + '] has ended..');\n\n      callback = this._taskCallback[payload.taskId];\n      responseData = payload.response;\n\n      if (!callback || typeof callback !== 'function') {\n        debugWorker('worker [' + this.id + '] - callback registered for the task\\'s response (' + payload.taskId + ') is not a function');\n        return;\n      }\n\n      if (payload.error) {\n        return callback(new Error(payload.error.message || 'An error has occurred when trying to process the task'));\n      }\n\n      callback(null, responseData);\n    }\n  };\n\n  ElectronWorker.prototype.start = function start(cb) {\n    var _this2 = this;\n\n    var isDone = false;\n\n    if (!isValidConnectionMode(this.options.connectionMode)) {\n      return cb(new Error('invalid connection mode: ' + this.options.connectionMode));\n    }\n\n    debugWorker('starting worker [' + this.id + ']..');\n\n    this.findFreePort(function (err, port) {\n      var childArgs = undefined,\n          childOpts = undefined;\n\n      var _options = _this2.options;\n      var electronArgs = _options.electronArgs;\n      var pathToElectron = _options.pathToElectron;\n      var pathToScript = _options.pathToScript;\n      var hostEnvVarName = _options.hostEnvVarName;\n      var portEnvVarName = _options.portEnvVarName;\n      var host = _options.host;\n      var debug = _options.debug;\n      var debugBrk = _options.debugBrk;\n      var env = _options.env;\n      var stdio = _options.stdio;\n      var connectionMode = _options.connectionMode;\n\n      if (!env) {\n        env = {};\n      }\n\n      childArgs = electronArgs.slice();\n      childArgs.unshift(pathToScript);\n\n      if (debugBrk != null) {\n        childArgs.unshift('--debug-brk=' + debugBrk);\n      } else if (debug != null) {\n        childArgs.unshift('--debug=' + debug);\n      }\n\n      if (err) {\n        debugWorker('couldn\\'t find free port for worker [' + _this2.id + ']..');\n        return cb(err);\n      }\n\n      _this2.port = port;\n\n      childOpts = {\n        env: _extends({}, env, {\n          ELECTRON_WORKER_ID: _this2.id,\n          // propagate the DISPLAY env var to make it work on LINUX\n          DISPLAY: process.env.DISPLAY\n        })\n      };\n\n      // we send host and port as env vars to child process in server mode\n      if (connectionMode === 'server') {\n        childOpts.stdio = 'pipe';\n        childOpts.env[hostEnvVarName] = host;\n        childOpts.env[portEnvVarName] = port;\n      } else if (connectionMode === 'ipc') {\n        childOpts.stdio = ['pipe', 'pipe', 'pipe', 'ipc'];\n      }\n\n      if (stdio != null) {\n        childOpts.stdio = stdio;\n      }\n\n      debugWorker('spawning process for worker [' + _this2.id + '] with args:', childArgs, 'and options:', childOpts);\n\n      _this2._childProcess = _child_process2['default'].spawn(pathToElectron, childArgs, childOpts);\n\n      // ipc connection is required for ipc mode\n      if (connectionMode === 'ipc' && !_this2._childProcess.send) {\n        return cb(new Error('ipc mode requires a ipc connection, if you\\'re using stdio option make sure you are setting up ipc'));\n      }\n\n      _this2._handleSpawnError = function (spawnError) {\n        debugWorker('worker [' + this.id + '] spawn error callback..');\n\n        if (!this.firstStart) {\n          isDone = true;\n          this._earlyError = true;\n          debugWorker('worker [' + this.id + '] start was canceled because an early error: ' + spawnError.message);\n          cb(spawnError);\n        }\n      };\n\n      _this2._handleSpawnError = _this2._handleSpawnError.bind(_this2);\n\n      _this2._childProcess.once('error', _this2._handleSpawnError);\n\n      _this2._childProcess.on('error', _this2.onWorkerProcessError);\n\n      _this2._childProcess.on('exit', _this2.onWorkerProcessExitTryToRecyle);\n\n      if (connectionMode === 'ipc') {\n        _this2._childProcess.on('message', _this2.onWorkerProcessIpcMessage);\n      }\n\n      _this2.emit('processCreated');\n\n      setImmediate(function () {\n        // the workers were killed explicitly by the user\n        if (_this2._hardKill || isDone) {\n          return;\n        }\n\n        if (_this2._childProcess == null) {\n          debugWorker('There is no child process for worker [' + _this2.id + ']..');\n          return cb(new Error('There is no child process for worker'));\n        }\n\n        debugWorker('checking if worker [' + _this2.id + '] is alive..');\n\n        _this2.checkAlive(function (checkAliveErr) {\n          if (isDone) {\n            return;\n          }\n\n          if (checkAliveErr) {\n            debugWorker('worker [' + _this2.id + '] is not alive..');\n            return cb(checkAliveErr);\n          }\n\n          _this2._earlyError = false;\n          _this2._childProcess.removeListener('error', _this2._handleSpawnError);\n\n          if (!_this2.firstStart) {\n            _this2.firstStart = true;\n          }\n\n          debugWorker('worker [' + _this2.id + '] is alive..');\n          cb();\n        });\n      });\n    });\n  };\n\n  ElectronWorker.prototype.checkAlive = function checkAlive(cb, shot) {\n    var shotCount = shot || 1,\n        connectionMode = this.options.connectionMode;\n\n    function statusHandler(err, statusWorker) {\n      var _this3 = this;\n\n      if (!err && statusWorker === 'open') {\n        return cb();\n      }\n\n      if (connectionMode === 'server' && shotCount > 50) {\n        return cb(new Error('Unable to reach electron worker - mode: ' + connectionMode));\n      }\n\n      if (connectionMode === 'ipc' && err) {\n        return cb(err);\n      }\n\n      shotCount++;\n\n      // re-try check\n      if (connectionMode === 'server') {\n        setTimeout(function () {\n          _this3.checkAlive(cb, shotCount);\n        }, 100);\n      }\n    }\n\n    if (connectionMode === 'server') {\n      _checkPortStatus2['default'](this.port, this.options.host, statusHandler.bind(this));\n    } else if (connectionMode === 'ipc') {\n      _checkIpcStatus2['default'](this._childProcess, statusHandler.bind(this));\n    }\n  };\n\n  ElectronWorker.prototype.execute = function execute(data, cb) {\n    var _this4 = this;\n\n    var connectionMode = this.options.connectionMode,\n        httpOpts = undefined,\n        req = undefined,\n        json = undefined,\n        taskId = undefined;\n\n    debugWorker('new task for worker [' + this.id + ']..');\n\n    this.emit('task');\n\n    if (this._hardKill) {\n      debugWorker('task execution stopped because worker [' + this.id + '] was killed by the user..');\n      return;\n    }\n\n    if (connectionMode === 'ipc') {\n      debugWorker('creating ipc task message for worker [' + this.id + ']..');\n\n      taskId = _uuid2['default'].v1();\n\n      this._taskCallback[taskId] = function () {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this4.emit('taskEnd');\n        cb.apply(undefined, args);\n      };\n\n      return this._childProcess.send({\n        workerEvent: 'task',\n        taskId: taskId,\n        payload: data\n      });\n    }\n\n    debugWorker('creating request for worker [' + this.id + ']..');\n\n    httpOpts = {\n      hostname: this.options.host,\n      port: this.port,\n      path: '/',\n      method: 'POST'\n    };\n\n    req = _http2['default'].request(httpOpts, function (res) {\n      var result = '';\n\n      res.on('data', function (chunk) {\n        result += chunk;\n      });\n\n      res.on('end', function () {\n        var responseData = undefined;\n\n        debugWorker('request in worker [' + _this4.id + '] has ended..');\n\n        _this4.emit('taskEnd');\n\n        try {\n          debugWorker('trying to parse worker [' + _this4.id + '] response..');\n          responseData = result ? JSON.parse(result) : null;\n        } catch (err) {\n          debugWorker('couldn\\'t parse response for worker [' + _this4.id + ']..');\n          return cb(err);\n        }\n\n        debugWorker('response has been parsed correctly for worker [' + _this4.id + ']..');\n        cb(null, responseData);\n      });\n    });\n\n    req.setHeader('Content-Type', 'application/json');\n    json = JSON.stringify(data);\n    req.setHeader('Content-Length', Buffer.byteLength(json));\n\n    debugWorker('trying to communicate with worker [' + this.id + '], request options:', httpOpts, 'data:', json);\n\n    req.write(json);\n\n    req.on('error', function (err) {\n      debugWorker('error when trying to communicate with worker [' + _this4.id + ']..');\n      cb(err);\n    });\n\n    req.end();\n  };\n\n  ElectronWorker.prototype.recycle = function recycle() {\n    var _this5 = this;\n\n    var cb = undefined,\n        revive = undefined;\n\n    debugWorker('recycling worker [' + this.id + ']..');\n\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    if (args.length < 2) {\n      cb = args[0];\n      revive = true;\n    } else {\n      cb = args[1];\n      revive = args[0];\n    }\n\n    if (this._childProcess) {\n      this.isRecycling = true;\n      // mark worker as busy before recycling\n      this.isBusy = true;\n\n      this.emit('recycling');\n\n      if (this._hardKill) {\n        debugWorker('recycling was stopped because worker [' + this.id + '] was killed by the user..');\n        return;\n      }\n\n      this.kill();\n\n      debugWorker('trying to re-start child process for worker [' + this.id + ']..');\n\n      this.start(function (startErr) {\n        _this5.isRecycling = false;\n        // mark worker as free after recycling\n        _this5.isBusy = false;\n\n        // if there is a error on worker recycling, revive it on next execute\n        if (startErr) {\n          _this5.shouldRevive = Boolean(revive);\n\n          debugWorker('couldn\\'t recycle worker [' + _this5.id + '], should revive: ' + _this5.shouldRevive);\n\n          cb(startErr);\n          _this5.emit('recyclingError', startErr);\n          return;\n        }\n\n        debugWorker('worker [' + _this5.id + '] has been recycled..');\n\n        _this5.shouldRevive = false;\n\n        cb();\n\n        _this5.emit('recycled');\n      });\n    } else {\n      debugWorker('there is no child process to recycle - worker [' + this.id + ']');\n    }\n  };\n\n  ElectronWorker.prototype.kill = function kill(hardKill) {\n    var connectionMode = this.options.connectionMode;\n\n    debugWorker('killing worker [' + this.id + ']..');\n\n    this.emit('kill');\n\n    this._hardKill = Boolean(hardKill);\n\n    if (this._childProcess) {\n      if (this._childProcess.connected) {\n        debugWorker('closing ipc connection - worker [' + this.id + ']..');\n        this._childProcess.disconnect();\n      }\n\n      // clean previous listeners\n      if (this._handleSpawnError) {\n        this._childProcess.removeListener('error', this._handleSpawnError);\n      }\n\n      this._childProcess.removeListener('error', this.onWorkerProcessError);\n      this._childProcess.removeListener('exit', this.onWorkerProcessExitTryToRecyle);\n\n      if (connectionMode === 'ipc') {\n        this._childProcess.removeListener('message', this.onWorkerProcessIpcMessage);\n      }\n\n      // guard against closing a process that has been closed before\n      if (!this.exit) {\n        if (this.options.killSignal) {\n          debugWorker('killing worker [' + this.id + '] with custom signal:', this.options.killSignal);\n          this._childProcess.kill(this.options.killSignal);\n        } else {\n          this._childProcess.kill();\n        }\n\n        if (!hardKill) {\n          this.onWorkerProcessExitTryToRecyle();\n        }\n      }\n\n      this._childProcess = undefined;\n    } else {\n      debugWorker('there is no child process to kill - worker [' + this.id + ']');\n    }\n  };\n\n  return ElectronWorker;\n})(_events.EventEmitter);\n\nexports['default'] = ElectronWorker;\nmodule.exports = exports['default'];","/home/travis/build/npmtest/node-npmtest-electron-workers/node_modules/electron-workers/lib/checkPortStatus.js":"'use strict';\n\nexports.__esModule = true;\n\nvar _net = require('net');\n\nexports['default'] = function (port, host, cb) {\n  var timeout = 50,\n      connectionRefused = false,\n      portStatus = null,\n      error = null,\n      socket = undefined;\n\n  socket = new _net.Socket();\n\n  // Socket connection established, port is open\n  socket.on('connect', function () {\n    portStatus = 'open';\n    socket.destroy();\n  });\n\n  // If no response, assume port is not listening\n  socket.setTimeout(timeout);\n\n  socket.on('timeout', function () {\n    portStatus = 'closed';\n    error = new Error('Worker timeout (' + timeout + ' ms) ocurred waiting for ' + host + ':' + port + ' to be available');\n    socket.destroy();\n  });\n\n  socket.on('error', function (exception) {\n    if (exception.code !== 'ECONNREFUSED') {\n      error = exception;\n    } else {\n      connectionRefused = true;\n    }\n\n    portStatus = 'closed';\n  });\n\n  // Return after the socket has closed\n  socket.on('close', function (exception) {\n    if (exception && !connectionRefused) {\n      error = exception;\n    } else {\n      error = null;\n    }\n\n    cb(error, portStatus);\n  });\n\n  socket.connect(port, host);\n};\n\nmodule.exports = exports['default'];","/home/travis/build/npmtest/node-npmtest-electron-workers/node_modules/electron-workers/lib/checkIpcStatus.js":"'use strict';\n\nexports.__esModule = true;\n\nexports['default'] = function (processObj, cb) {\n  var timeout = 100,\n      isDone = false,\n      timeoutId = undefined;\n\n  function pongHandler(payload) {\n    if (payload && payload.workerEvent === 'pong') {\n      isDone = true;\n      clearTimeout(timeoutId);\n      processObj.removeListener('message', pongHandler);\n      cb(null, 'open');\n    }\n  }\n\n  processObj.on('message', pongHandler);\n\n  tryCommunication();\n\n  function tryCommunication() {\n    var shotCount = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n\n    if (isDone) {\n      return;\n    }\n\n    processObj.send({\n      workerEvent: 'ping'\n    }, undefined, function (err) {\n      if (isDone) {\n        return;\n      }\n\n      if (err) {\n        isDone = true;\n        cb(new Error('message could not be sent to electron process'));\n      }\n    });\n\n    timeoutId = setTimeout(function () {\n      if (isDone) {\n        return;\n      }\n\n      if (shotCount > 200) {\n        isDone = true;\n        return cb(new Error('Worker timeout (' + timeout + ' ms) ocurred waiting for ipc connection to be available'));\n      }\n\n      tryCommunication(shotCount + 1);\n    }, timeout);\n  }\n};\n\nmodule.exports = exports['default'];"}